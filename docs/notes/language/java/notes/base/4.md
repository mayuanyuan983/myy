# JVM结构

## 虚拟机

1.类装载子系统

2.运行时数据区（内存模型）

3.字节码执行引擎：执行代码、修改程序计数器

## JVM内存模型

### 线程私有

#### 栈

栈(线程)：线程的局部变量，栈内部是由一系列的栈帧组成。
栈帧：一个方法对应一块栈帧内存区域

栈：FILO 先进后出 first in last out

先调用的方法先分配内存，后调用的方法后先销毁内存

**栈帧的组成：**

1.局部变量表

2.操作数栈：放程序运行过程中的操作数的一块临时内存空间

3.动态链接：把符号(程序方法名)的代码位置的入口地址放入动态链接

4.方法出口

`javap -c User.class`对代码进行反汇编



栈里的局部变量存了堆的对象的引用内存地址

#### 程序计数器

PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。

(存储当前线程即将运行的指令代码的内存地址)

多线程抢占时间片时，那一行代码执行完毕才会被挂起。恢复时，就可以从程序计数器记录的位置继续运行。



代码是在方法区里

字节码执行引擎是负责执行代码的

程序计数器是由字节码执行引擎在执行代码时动态修改的。

#### 本地方法栈

native修饰的方法都是本地方法

native方法是用C++实现的

native方法使用的内存空间是用本地方法栈的

### 线程共有

#### 堆

堆：new出来的对象都在堆里

**垃圾回收**

堆内部由年轻代、老年代来组成，年轻代占1/3，老年代2/3

年轻代分Eden和S0、S1区，占比为8:1:1

如果Eden区满了，这会做一次Minor GC/Young GC

垃圾收集机制：字节码执行引擎后台会开启垃圾收集线程

可达性分析算法：从GC Roots引用的对象开始向下，寻找引用的其他对象，标记为非垃圾对象，其他的为垃圾对象。

GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等

Eden区满后垃圾回收：做可达性分析，将非垃圾对象移入S0、Eden区清空垃圾对象，分代年龄+1

S0区满后垃圾回收：将S0非垃圾对象移入S1，分代年龄+1

S1区年龄到达15，放入老年代

老年代满后，做一次FULL GC

FULL GC后如果还是满，再向老年代放对象，则会OOM

[Jvisualvm安装Visual GC插件](https://www.jianshu.com/p/48db4a29300f)

#### 方法区(元空间)

常量+静态变量+类信息

静态变量如果是对象，放的也是对象在堆中的内存地址

## Arthas详解

[arthas 用户文档](https://arthas.gitee.io/)

`java -jar arthas-boot.jar`启动arthas

### 命令

输入 `dashboard` 可以查看整个进程的运行情况，线程、内存、GC、运行环境信息

能看到CPU占用率很高的线程ID

输入 `thread 线程id` 可以看到线程堆栈

输入 `thread -b` 可以查看线程死锁

输入 `jad 类全名` 可以反编译，这样可以方便我们查看线上代码是否是正确的版

使用 `ognl` 命令可以查看线上系统变量的值，甚至可以修改变量的值

更多命令，可查看[命令列表](https://arthas.gitee.io/doc/commands.html)

## JVM调优目的

减少STW

STW：stop the world 停止运行用户线程

GC内存回收时，会执行STW

**Java虚拟机为什么要执行STW**

如果不STW，对象里的垃圾对象标记会发生变化，不让对象的状态在GC过程中发生变化，这样就能快速做完垃圾回收。

## 电商JVM参数调优

4核8G系统

配置JVM参数



300单/秒，假设对象大小1k(字段大小之和，int 4字节，String 4-8)

每秒300KB订单对象生成，还有其他对象(库存、优惠券等)，放大20倍

再加上还有其他操作，如查询订单，再放大10倍

`300KB * 20 * 10 / 秒` 每秒产生60MB的对象大小放入堆，1秒后都变为垃圾（方法1秒内执行完毕了，对象变为垃圾对象）

eden区800M，大约14秒占满eden

S0、S1 100M

一部分还没结束的对象约60M放入S0区时，因为占用超过50%，触发对象动态年龄判断，直接进入老年代

**如何调优**

减少老年代，增加新生代的大小

调整分配比例。尽量不让一些很容易变成垃圾的对象进入老年代。

### 对象放入老年代的情况

1.长期存活的对象将进入老年代

2.大对象直接进入老年代

3.老年代空间分配担保机制

4.对象动态年龄判断

S区超过50%直接进入老年代

## 单机几十万并发的系统JVM

eden区过大，停顿时间过长，如何调优

选择合适的垃圾收集器

垃圾收集器的收集方法？