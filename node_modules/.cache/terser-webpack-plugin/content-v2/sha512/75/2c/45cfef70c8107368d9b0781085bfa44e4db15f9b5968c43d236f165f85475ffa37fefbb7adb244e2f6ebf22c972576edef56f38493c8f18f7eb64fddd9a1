{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{369:function(a,t,v){\"use strict\";v.r(t);var _=v(23),e=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[v(\"h1\",{attrs:{id:\"select\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#select\"}},[a._v(\"#\")]),a._v(\" SELECT *\")]),a._v(\" \"),v(\"p\",[v(\"a\",{attrs:{href:\"https://zhuanlan.zhihu.com/p/149981715\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a._v(\"为什么大家都说SELECT * 效率低\"),v(\"OutboundLink\")],1)]),a._v(\" \"),v(\"p\",[a._v(\"表查询一律不使用*，使用哪些字段必须写明。\")]),a._v(\" \"),v(\"ul\",[v(\"li\",[a._v(\"增加查询分析器解析成本\")]),a._v(\" \"),v(\"li\",[a._v(\"增减字段容易与resultMap配置不一致\")]),a._v(\" \"),v(\"li\",[a._v(\"无用字段增加网络消耗，尤其是text类型的字段\")])]),a._v(\" \"),v(\"h3\",{attrs:{id:\"不需要的列会增加数据传输时间和网络开销\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#不需要的列会增加数据传输时间和网络开销\"}},[a._v(\"#\")]),a._v(\" 不需要的列会增加数据传输时间和网络开销\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[a._v(\"用SELECT *数据库需要解析更多的对象、字段、权限、属性等内容，在SQL语句复杂，硬解析较多的情况下，会对数据库造成沉重的负担。\")]),a._v(\" \"),v(\"li\",[a._v(\"增大网络开销；*有时会带上入log、IconMD5之类的无用且大文本字段，数据传输size会几何增长。如果DB和应用程序不在同一台机器，这种开销非常明显\")]),a._v(\" \"),v(\"li\",[a._v(\"即使mysql服务器和客户端在同一台机器上，使用的协议还是tcp，通信也是需要额外的时间\")])]),a._v(\" \"),v(\"h3\",{attrs:{id:\"对于无用的大字段-varchar、blob、text-会增加io操作\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对于无用的大字段-varchar、blob、text-会增加io操作\"}},[a._v(\"#\")]),a._v(\" 对于无用的大字段（varchar、blob、text）会增加IO操作\")]),a._v(\" \"),v(\"p\",[a._v(\"长度超过728字节时，会先把超出的数据序列化到另一个地方，因此读取这条记录会增加一次IO操作。（MySQL InnoDB）\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"失去mysql优化器-覆盖索引-策略优化的可能性\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#失去mysql优化器-覆盖索引-策略优化的可能性\"}},[a._v(\"#\")]),a._v(\" 失去MySQL优化器“覆盖索引”策略优化的可能性\")]),a._v(\" \"),v(\"p\",[a._v(\"ELECT * 杜绝了覆盖索引的可能性，而基于MySQL优化器的“覆盖索引”策略又是速度极快，效率极高，业界极为推荐的查询优化方式。\")]),a._v(\" \"),v(\"p\",[a._v(\"例如，有一个表为t(a,b,c,d,e,f)，其中，a为主键，b列有索引。\")]),a._v(\" \"),v(\"p\",[a._v(\"那么，在磁盘上有两棵 B+ 树，即聚集索引和辅助索引（包括单列索引、联合索引），分别保存(a,b,c,d,e,f)和(a,b)，如果查询条件中where条件可以通过b列的索引过滤掉一部分记录，查询就会先走辅助索引，如果用户只需要a列和b列的数据，直接通过辅助索引就可以知道用户查询的数据。\")]),a._v(\" \"),v(\"p\",[a._v(\"如果用户使用select *，获取了不需要的数据，则首先通过辅助索引过滤数据，然后再通过聚集索引获取所有的列，这就多了一次b+树查询，速度必然会慢很多。\")]),a._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://pic3.zhimg.com/v2-9017bbe21e6c86b653b89cbed12f5502_b.jpg\",alt:\"img\"}})]),a._v(\" \"),v(\"p\",[a._v(\"由于辅助索引的数据比聚集索引少很多，很多情况下，通过辅助索引进行覆盖索引（通过索引就能获取用户需要的所有列），都不需要读磁盘，直接从内存取，而聚集索引很可能数据在磁盘（外存）中（取决于buffer pool的大小和命中率），这种情况下，一个是内存读，一个是磁盘读，速度差异就很显著了，几乎是数量级的差异。\")]),a._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://pic3.zhimg.com/v2-033336dd184b77f37346ac752f7fd306_b.jpg\",alt:\"img\"}})]),a._v(\" \"),v(\"h2\",{attrs:{id:\"二、索引知识延申\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、索引知识延申\"}},[a._v(\"#\")]),a._v(\" 二、索引知识延申\")]),a._v(\" \"),v(\"p\",[a._v(\"上面提到了辅助索引，在MySQL中辅助索引包括单列索引、联合索引（多列联合），单列索引就不再赘述了，这里提一下联合索引的作用\")]),a._v(\" \"),v(\"p\",[v(\"strong\",[a._v(\"联合索引 (a,b,c)\")])]),a._v(\" \"),v(\"p\",[a._v(\"联合索引 (a,b,c) 实际建立了 (a)、(a,b)、(a,b,c) 三个索引\")]),a._v(\" \"),v(\"p\",[a._v(\"我们可以将组合索引想成书的一级目录、二级目录、三级目录，如index(a,b,c)，相当于a是一级目录，b是一级目录下的二级目录，c是二级目录下的三级目录。要使用某一目录，必须先使用其上级目录，一级目录除外。\")]),a._v(\" \"),v(\"p\",[a._v(\"如下：\")]),a._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://pic2.zhimg.com/v2-f7e2ed7e896e84e20930849a60e2aecd_b.jpg\",alt:\"img\"}})]),a._v(\" \"),v(\"p\",[v(\"strong\",[a._v(\"联合索引的优势\")])]),a._v(\" \"),v(\"p\",[a._v(\"1） 减少开销\")]),a._v(\" \"),v(\"p\",[a._v(\"建一个联合索引 (a,b,c) ，实际相当于建了 (a)、(a,b)、(a,b,c) 三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！\")]),a._v(\" \"),v(\"p\",[a._v(\"2）覆盖索引\")]),a._v(\" \"),v(\"p\",[a._v(\"对联合索引 (a,b,c)，如果有如下 sql 的，\")]),a._v(\" \"),v(\"div\",{staticClass:\"language-mysql line-numbers-mode\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[a._v(\"SELECT a,b,c from table where a='xx' and b = 'xx';\\n\")])]),a._v(\" \"),v(\"div\",{staticClass:\"line-numbers-wrapper\"},[v(\"span\",{staticClass:\"line-number\"},[a._v(\"1\")]),v(\"br\")])]),v(\"p\",[a._v(\"那么 MySQL 可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机 io 操作。减少 io 操作，特别是随机 io 其实是 DBA 主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。\")]),a._v(\" \"),v(\"p\",[a._v(\"3）效率高\")]),a._v(\" \"),v(\"p\",[a._v(\"索引列多，通过联合索引筛选出的数据越少。比如有 1000W 条数据的表，有如下SQL:\")]),a._v(\" \"),v(\"div\",{staticClass:\"language-mysql line-numbers-mode\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[a._v(\"select col1,col2,col3 from table where col1=1 and col2=2 and col3=3;\\n\")])]),a._v(\" \"),v(\"div\",{staticClass:\"line-numbers-wrapper\"},[v(\"span\",{staticClass:\"line-number\"},[a._v(\"1\")]),v(\"br\")])]),v(\"p\",[a._v(\"假设：假设每个条件可以筛选出 10% 的数据。\")]),a._v(\" \"),v(\"ul\",[v(\"li\",[a._v(\"A. 如果只有单列索引，那么通过该索引能筛选出 1000W10%=100w 条数据，然后再回表从 100w 条数据中找到符合 col2=2 and col3= 3 的数据，然后再排序，再分页，以此类推（递归）；\")]),a._v(\" \"),v(\"li\",[a._v(\"B. 如果是（col1,col2,col3）联合索引，通过三列索引筛选出 1000w10% 10% *10%=1w，效率提升可想而知！\")])]),a._v(\" \"),v(\"p\",[v(\"strong\",[a._v(\"索引是建的越多越好吗\")])]),a._v(\" \"),v(\"p\",[a._v(\"答案自然是否定的\")]),a._v(\" \"),v(\"ul\",[v(\"li\",[a._v(\"数据量小的表不需要建立索引，建立会增加额外的索引开销\")]),a._v(\" \"),v(\"li\",[a._v(\"不经常引用的列不要建立索引，因为不常用，即使建立了索引也没有多大意义\")]),a._v(\" \"),v(\"li\",[a._v(\"经常频繁更新的列不要建立索引，因为肯定会影响插入或更新的效率\")]),a._v(\" \"),v(\"li\",[a._v(\"数据重复且分布平均的字段，因此他建立索引就没有太大的效果（例如性别字段，只有男女，不适合建立索引）\")]),a._v(\" \"),v(\"li\",[a._v(\"数据变更需要维护索引，意味着索引越多维护成本越高。\")]),a._v(\" \"),v(\"li\",[a._v(\"更多的索引也需要更多的存储空间\")])])])}),[],!1,null,null,null);t.default=e.exports}}]);","extractedComments":[]}