(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{441:function(v,_,a){"use strict";a.r(_);var t=a(62),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"jvm结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm结构"}},[v._v("#")]),v._v(" JVM结构")]),v._v(" "),a("h2",{attrs:{id:"虚拟机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机"}},[v._v("#")]),v._v(" 虚拟机")]),v._v(" "),a("p",[v._v("1.类装载子系统")]),v._v(" "),a("p",[v._v("2.运行时数据区（内存模型）")]),v._v(" "),a("p",[v._v("3.字节码执行引擎：执行代码、修改程序计数器")]),v._v(" "),a("h2",{attrs:{id:"jvm内存模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存模型"}},[v._v("#")]),v._v(" JVM内存模型")]),v._v(" "),a("h3",{attrs:{id:"线程私有"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程私有"}},[v._v("#")]),v._v(" 线程私有")]),v._v(" "),a("h4",{attrs:{id:"栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[v._v("#")]),v._v(" 栈")]),v._v(" "),a("p",[v._v("栈(线程)：线程的局部变量，栈内部是由一系列的栈帧组成。\n栈帧：一个方法对应一块栈帧内存区域")]),v._v(" "),a("p",[v._v("栈：FILO 先进后出 first in last out")]),v._v(" "),a("p",[v._v("先调用的方法先分配内存，后调用的方法后先销毁内存")]),v._v(" "),a("p",[a("strong",[v._v("栈帧的组成：")])]),v._v(" "),a("p",[v._v("1.局部变量表")]),v._v(" "),a("p",[v._v("2.操作数栈：放程序运行过程中的操作数的一块临时内存空间")]),v._v(" "),a("p",[v._v("3.动态链接：把符号(程序方法名)的代码位置的入口地址放入动态链接")]),v._v(" "),a("p",[v._v("4.方法出口")]),v._v(" "),a("p",[a("code",[v._v("javap -c User.class")]),v._v("对代码进行反汇编")]),v._v(" "),a("p",[v._v("栈里的局部变量存了堆的对象的引用内存地址")]),v._v(" "),a("h4",{attrs:{id:"程序计数器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[v._v("#")]),v._v(" 程序计数器")]),v._v(" "),a("p",[v._v("PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。")]),v._v(" "),a("p",[v._v("(存储当前线程即将运行的指令代码的内存地址)")]),v._v(" "),a("p",[v._v("多线程抢占时间片时，那一行代码执行完毕才会被挂起。恢复时，就可以从程序计数器记录的位置继续运行。")]),v._v(" "),a("p",[v._v("代码是在方法区里")]),v._v(" "),a("p",[v._v("字节码执行引擎是负责执行代码的")]),v._v(" "),a("p",[v._v("程序计数器是由字节码执行引擎在执行代码时动态修改的。")]),v._v(" "),a("h4",{attrs:{id:"本地方法栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[v._v("#")]),v._v(" 本地方法栈")]),v._v(" "),a("p",[v._v("native修饰的方法都是本地方法")]),v._v(" "),a("p",[v._v("native方法是用C++实现的")]),v._v(" "),a("p",[v._v("native方法使用的内存空间是用本地方法栈的")]),v._v(" "),a("h3",{attrs:{id:"线程共有"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程共有"}},[v._v("#")]),v._v(" 线程共有")]),v._v(" "),a("h4",{attrs:{id:"堆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),a("p",[v._v("堆：new出来的对象都在堆里")]),v._v(" "),a("p",[a("strong",[v._v("垃圾回收")])]),v._v(" "),a("p",[v._v("堆内部由年轻代、老年代来组成，年轻代占1/3，老年代2/3")]),v._v(" "),a("p",[v._v("年轻代分Eden和S0、S1区，占比为8:1:1")]),v._v(" "),a("p",[v._v("如果Eden区满了，这会做一次Minor GC/Young GC")]),v._v(" "),a("p",[v._v("垃圾收集机制：字节码执行引擎后台会开启垃圾收集线程")]),v._v(" "),a("p",[v._v("可达性分析算法：从GC Roots引用的对象开始向下，寻找引用的其他对象，标记为非垃圾对象，其他的为垃圾对象。")]),v._v(" "),a("p",[v._v("GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等")]),v._v(" "),a("p",[v._v("Eden区满后垃圾回收：做可达性分析，将非垃圾对象移入S0、Eden区清空垃圾对象，分代年龄+1")]),v._v(" "),a("p",[v._v("S0区满后垃圾回收：将S0非垃圾对象移入S1，分代年龄+1")]),v._v(" "),a("p",[v._v("S1区年龄到达15，放入老年代")]),v._v(" "),a("p",[v._v("老年代满后，做一次FULL GC")]),v._v(" "),a("p",[v._v("FULL GC后如果还是满，再向老年代放对象，则会OOM")]),v._v(" "),a("p",[a("a",{attrs:{href:"https://www.jianshu.com/p/48db4a29300f",target:"_blank",rel:"noopener noreferrer"}},[v._v("Jvisualvm安装Visual GC插件"),a("OutboundLink")],1)]),v._v(" "),a("h4",{attrs:{id:"方法区-元空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法区-元空间"}},[v._v("#")]),v._v(" 方法区(元空间)")]),v._v(" "),a("p",[v._v("常量+静态变量+类信息")]),v._v(" "),a("p",[v._v("静态变量如果是对象，放的也是对象在堆中的内存地址")]),v._v(" "),a("h2",{attrs:{id:"arthas详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arthas详解"}},[v._v("#")]),v._v(" Arthas详解")]),v._v(" "),a("p",[a("a",{attrs:{href:"https://arthas.gitee.io/",target:"_blank",rel:"noopener noreferrer"}},[v._v("arthas 用户文档"),a("OutboundLink")],1)]),v._v(" "),a("p",[a("code",[v._v("java -jar arthas-boot.jar")]),v._v("启动arthas")]),v._v(" "),a("h3",{attrs:{id:"命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命令"}},[v._v("#")]),v._v(" 命令")]),v._v(" "),a("p",[v._v("输入 "),a("code",[v._v("dashboard")]),v._v(" 可以查看整个进程的运行情况，线程、内存、GC、运行环境信息")]),v._v(" "),a("p",[v._v("能看到CPU占用率很高的线程ID")]),v._v(" "),a("p",[v._v("输入 "),a("code",[v._v("thread 线程id")]),v._v(" 可以看到线程堆栈")]),v._v(" "),a("p",[v._v("输入 "),a("code",[v._v("thread -b")]),v._v(" 可以查看线程死锁")]),v._v(" "),a("p",[v._v("输入 "),a("code",[v._v("jad 类全名")]),v._v(" 可以反编译，这样可以方便我们查看线上代码是否是正确的版")]),v._v(" "),a("p",[v._v("使用 "),a("code",[v._v("ognl")]),v._v(" 命令可以查看线上系统变量的值，甚至可以修改变量的值")]),v._v(" "),a("p",[v._v("更多命令，可查看"),a("a",{attrs:{href:"https://arthas.gitee.io/doc/commands.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("命令列表"),a("OutboundLink")],1)]),v._v(" "),a("h2",{attrs:{id:"jvm调优目的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm调优目的"}},[v._v("#")]),v._v(" JVM调优目的")]),v._v(" "),a("p",[v._v("减少STW")]),v._v(" "),a("p",[v._v("STW：stop the world 停止运行用户线程")]),v._v(" "),a("p",[v._v("GC内存回收时，会执行STW")]),v._v(" "),a("p",[a("strong",[v._v("Java虚拟机为什么要执行STW")])]),v._v(" "),a("p",[v._v("如果不STW，对象里的垃圾对象标记会发生变化，不让对象的状态在GC过程中发生变化，这样就能快速做完垃圾回收。")]),v._v(" "),a("h2",{attrs:{id:"电商jvm参数调优"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#电商jvm参数调优"}},[v._v("#")]),v._v(" 电商JVM参数调优")]),v._v(" "),a("p",[v._v("4核8G系统")]),v._v(" "),a("p",[v._v("配置JVM参数")]),v._v(" "),a("p",[v._v("300单/秒，假设对象大小1k(字段大小之和，int 4字节，String 4-8)")]),v._v(" "),a("p",[v._v("每秒300KB订单对象生成，还有其他对象(库存、优惠券等)，放大20倍")]),v._v(" "),a("p",[v._v("再加上还有其他操作，如查询订单，再放大10倍")]),v._v(" "),a("p",[a("code",[v._v("300KB * 20 * 10 / 秒")]),v._v(" 每秒产生60MB的对象大小放入堆，1秒后都变为垃圾（方法1秒内执行完毕了，对象变为垃圾对象）")]),v._v(" "),a("p",[v._v("eden区800M，大约14秒占满eden")]),v._v(" "),a("p",[v._v("S0、S1 100M")]),v._v(" "),a("p",[v._v("一部分还没结束的对象约60M放入S0区时，因为占用超过50%，触发对象动态年龄判断，直接进入老年代")]),v._v(" "),a("p",[a("strong",[v._v("如何调优")])]),v._v(" "),a("p",[v._v("减少老年代，增加新生代的大小")]),v._v(" "),a("p",[v._v("调整分配比例。尽量不让一些很容易变成垃圾的对象进入老年代。")]),v._v(" "),a("h3",{attrs:{id:"对象放入老年代的情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象放入老年代的情况"}},[v._v("#")]),v._v(" 对象放入老年代的情况")]),v._v(" "),a("p",[v._v("1.长期存活的对象将进入老年代")]),v._v(" "),a("p",[v._v("2.大对象直接进入老年代")]),v._v(" "),a("p",[v._v("3.老年代空间分配担保机制")]),v._v(" "),a("p",[v._v("4.对象动态年龄判断")]),v._v(" "),a("p",[v._v("S区超过50%直接进入老年代")]),v._v(" "),a("h2",{attrs:{id:"单机几十万并发的系统jvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单机几十万并发的系统jvm"}},[v._v("#")]),v._v(" 单机几十万并发的系统JVM")]),v._v(" "),a("p",[v._v("eden区过大，停顿时间过长，如何调优")]),v._v(" "),a("p",[v._v("选择合适的垃圾收集器")]),v._v(" "),a("p",[v._v("垃圾收集器的收集方法？")])])}),[],!1,null,null,null);_.default=r.exports}}]);