(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{452:function(a,t,s){"use strict";s.r(t);var r=s(62),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[a._v("#")]),a._v(" 面试题")]),a._v(" "),s("h2",{attrs:{id:"介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[a._v("#")]),a._v(" 介绍")]),a._v(" "),s("p",[a._v("学习中碰到的题目整理")]),a._v(" "),s("h2",{attrs:{id:"java基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java基础"}},[a._v("#")]),a._v(" Java基础")]),a._v(" "),s("h3",{attrs:{id:"特征"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特征"}},[a._v("#")]),a._v(" 特征")]),a._v(" "),s("p",[a._v("封装、继承、多态、抽象")]),a._v(" "),s("h3",{attrs:{id:"java数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java数据类型"}},[a._v("#")]),a._v(" Java数据类型")]),a._v(" "),s("p",[s("strong",[a._v("基本类型")])]),a._v(" "),s("p",[a._v("整数值型：byte、short、int、long")]),a._v(" "),s("p",[a._v("字符型：char")]),a._v(" "),s("p",[a._v("浮点类型：float、double")]),a._v(" "),s("p",[a._v("布尔型：boolean")]),a._v(" "),s("p",[a._v("整数型默认int型，小数默认double型，Float和Long类型必须加后缀")]),a._v(" "),s("p",[s("strong",[a._v("包装类型")])]),a._v(" "),s("p",[a._v("Byte、Short、Integer、Long、Character、Float、Double、Boolean")]),a._v(" "),s("p",[s("strong",[a._v("引用类型")])]),a._v(" "),s("p",[a._v("类、接口、数组、枚举、注解")]),a._v(" "),s("h3",{attrs:{id:"重写和重载的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重写和重载的区别"}},[a._v("#")]),a._v(" 重写和重载的区别")]),a._v(" "),s("p",[s("strong",[a._v("重写：")])]),a._v(" "),s("ul",[s("li",[a._v("方法名、参数、返回值相同")]),a._v(" "),s("li",[a._v("子类方法不能缩小分类方法的访问权限")]),a._v(" "),s("li",[a._v("子类方法不能抛出比父类方法更多的异常（子类方法可不抛出异常）")]),a._v(" "),s("li",[a._v("存在父类子类之间")]),a._v(" "),s("li",[a._v("方法定义为final不可重写")])]),a._v(" "),s("p",[s("strong",[a._v("重载：")])]),a._v(" "),s("ul",[s("li",[a._v("方法名相同，参数类型、个数、顺序至少一个不同，与返回值无关")]),a._v(" "),s("li",[a._v("不能重载只有返回值不同的方法名")]),a._v(" "),s("li",[a._v("存在于父类子类、同类中")])]),a._v(" "),s("h3",{attrs:{id:"java和c-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java和c-的区别"}},[a._v("#")]),a._v(" Java和C++的区别")]),a._v(" "),s("ul",[s("li",[a._v("都是面向对象的语言，支持封装、继承、多态")]),a._v(" "),s("li",[a._v("Java不提供指针来直接访问内存，内存更安全")]),a._v(" "),s("li",[a._v("Java类单继承，C++支持多重继承，Java可以接口多继承")]),a._v(" "),s("li",[a._v("Java有自动内存管理机制，不需要手动释放无用内存")])]),a._v(" "),s("h3",{attrs:{id:"string、stringbuffer、stringbuilder区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string、stringbuffer、stringbuilder区别"}},[a._v("#")]),a._v(" String、StringBuffer、StringBuilder区别")]),a._v(" "),s("p",[a._v("String是只读字符串，String引用的字符串内容是不能被改变的。每次对String类型进行改变时，都会生成一个新的String对象，然后将指针指向新的String对象。")]),a._v(" "),s("p",[a._v("StringBuffer和StringBuilder的字符串对象可以直接进行修改，它俩的方法完全相同，区别是StringBuilder是在单线程环境下使用的，因为它没有被同步锁"),s("code",[a._v("synchronized")]),a._v("修饰，因此效率比StringBuffer高。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。")]),a._v(" "),s("p",[a._v("操作少量数据：String")]),a._v(" "),s("p",[a._v("单线程操作字符串缓冲区下操作大量数据：StringBuilder")]),a._v(" "),s("p",[a._v("为了避免每个线程重复创建StringBuilder对象，会通过ThreadLocal+StringBuilder的方式，进行StringBuilder的重用。")]),a._v(" "),s("p",[a._v("多线程操作字符串缓冲区下操作大量数据：StringBuffer")]),a._v(" "),s("h3",{attrs:{id:"string为何不可变"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string为何不可变"}},[a._v("#")]),a._v(" String为何不可变")]),a._v(" "),s("p",[a._v("因为String类中使用final关键字字符数组保存字符串，所以String对象不可变")]),a._v(" "),s("p",[a._v("StringBuffer和StringBuilder都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符串数组保存字符串，但没有用final关键字修饰。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// String.java")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("char")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// AbstractStringBuilder.java")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("char")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("h3",{attrs:{id:"equals和-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#equals和-的区别"}},[a._v("#")]),a._v(" equals和==的区别")]),a._v(" "),s("p",[a._v("基本类型都是用==判断相等")]),a._v(" "),s("p",[a._v("对象引用")]),a._v(" "),s("ul",[s("li",[a._v("==判断引用所指的对象是否同一个")]),a._v(" "),s("li",[a._v("equals方法，是Object的成员函数，有些类会重写这个方法，用于判断对象的值相等")])]),a._v(" "),s("h3",{attrs:{id:"hashcode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashcode"}},[a._v("#")]),a._v(" hashCode")]),a._v(" "),s("p",[a._v("将对象放入集合中，首先判断要放入对象的hashCode是否和集合中的任何一个hashCode是否相等，如果不相等直接放入。如果相等，再通过equals方法判断是否有相等，如果不相等放入，否则不放入。")]),a._v(" "),s("p",[a._v("哈希碰撞：两个不相等的对象有相同的hashCode。所以我们重写了equals方法一定要重写hashCode方法，否则将会出现问题。")]),a._v(" "),s("p",[a._v("equals和hashCode的关系：")]),a._v(" "),s("ul",[s("li",[a._v("equals不相等，hashCode可能相等")]),a._v(" "),s("li",[a._v("equals相等，请重写hashCode方法，保证hashCode相等")])]),a._v(" "),s("h2",{attrs:{id:"反射"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#反射"}},[a._v("#")]),a._v(" 反射")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://www.cnblogs.com/zhaopei/p/reflection.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("二、什么是反射、反射可以做些什么 - 农码一生 - 博客园 (cnblogs.com)"),s("OutboundLink")],1)]),a._v(" "),s("h3",{attrs:{id:"什么是反射"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是反射"}},[a._v("#")]),a._v(" 什么是反射")]),a._v(" "),s("p",[a._v("反射是指程序可以访问、检测和修改它本身状态或行为的一种能力。")]),a._v(" "),s("p",[a._v("反射可以：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("获取类型的相关信息")])]),a._v(" "),s("li",[s("p",[a._v("动态调用方法")])]),a._v(" "),s("li",[s("p",[a._v("动态构造对象")])]),a._v(" "),s("li",[s("p",[a._v("从程序集中获得类型")])]),a._v(" "),s("li",[s("p",[a._v("在运行时构造一个类的对象(动态构造对象)")])]),a._v(" "),s("li",[s("p",[a._v("判断一个类所具有的成员变量和方法")])]),a._v(" "),s("li",[s("p",[a._v("调用一个对象的方法")])]),a._v(" "),s("li",[s("p",[a._v("生成动态代理")])])]),a._v(" "),s("p",[a._v("应用")]),a._v(" "),s("ul",[s("li",[a._v("Spring 框架的 IoC 基于反射创建对象和设置依赖属性。")]),a._v(" "),s("li",[a._v("Spring MVC 的请求调用对应方法，也是通过反射。")]),a._v(" "),s("li",[a._v("JDBC 的 "),s("code",[a._v("Class.forName(String className)")]),a._v(" 方法，也是使用反射。")])]),a._v(" "),s("h3",{attrs:{id:"class-forname和classloader区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#class-forname和classloader区别"}},[a._v("#")]),a._v(" Class.forName和ClassLoader区别")]),a._v(" "),s("p",[a._v("这两个都可以加载类")]),a._v(" "),s("p",[a._v("Class.forName加载.class文件到JVM，还会对类进行解释，执行static块（也可以参数控制是否加载static块）")]),a._v(" "),s("p",[a._v("ClassLoader只加载.class文件到JVM，不会执行static中的内容，只有在newInstance才会执行static块")]),a._v(" "),s("h2",{attrs:{id:"锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[a._v("#")]),a._v(" 锁")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://baijiahao.baidu.com/s?id=1653365466720197481&wfr=spider&for=pc",target:"_blank",rel:"noopener noreferrer"}},[a._v("一文足以了解什么是 Java 中的锁 (baidu.com)"),s("OutboundLink")],1)]),a._v(" "),s("h2",{attrs:{id:"mybatis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mybatis"}},[a._v("#")]),a._v(" Mybatis")]),a._v(" "),s("h3",{attrs:{id:"和-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别"}},[a._v("#")]),a._v(" #{}和${}的区别")]),a._v(" "),s("p",[a._v("${}是变量占位符，属于字符串替换，可以拼接参数，有SQL注入风险")]),a._v(" "),s("p",[a._v("#{}是SQL的参数占位符，会把SQL中的#{}替换为?，是预编译处理，有效防止SQL注入")]),a._v(" "),s("h3",{attrs:{id:"动态sql"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态sql"}},[a._v("#")]),a._v(" 动态SQL")]),a._v(" "),s("p",[a._v("在XML文件内，以XML标签的形式编写dong't")]),a._v(" "),s("p",[a._v("Mybatis 提供了 9 种动态 SQL 标签："),s("code",[a._v("<if />")]),a._v("、"),s("code",[a._v("<choose />")]),a._v("、"),s("code",[a._v("<when />")]),a._v("、"),s("code",[a._v("<otherwise />")]),a._v("、"),s("code",[a._v("<trim />")]),a._v("、"),s("code",[a._v("<where />")]),a._v("、"),s("code",[a._v("<set />")]),a._v("、"),s("code",[a._v("<foreach />")]),a._v("、"),s("code",[a._v("<bind />")]),a._v(" 。")])])}),[],!1,null,null,null);t.default=v.exports}}]);