(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{632:function(t,e,r){"use strict";r.r(e);var a=r(62),o=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"netty实战"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netty实战"}},[t._v("#")]),t._v(" Netty实战")]),t._v(" "),r("h2",{attrs:{id:"核心"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#核心"}},[t._v("#")]),t._v(" 核心")]),t._v(" "),r("p",[t._v("缓冲（buffer）")]),t._v(" "),r("p",[t._v("通道（channel）")]),t._v(" "),r("p",[t._v("事件模型（event model）")]),t._v(" "),r("h2",{attrs:{id:"_1-服务端"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-服务端"}},[t._v("#")]),t._v(" 1.服务端")]),t._v(" "),r("h3",{attrs:{id:"_1-1服务端启动"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1服务端启动"}},[t._v("#")]),t._v(" 1.1服务端启动")]),t._v(" "),r("p",[t._v("需要启动类（BootStrap）和处理业务的代码（ChannelHandler)")]),t._v(" "),r("div",{staticClass:"language-java line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-java"}},[r("code",[t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br")])]),r("ul",[r("li",[t._v("新建NioEventLoopGroup类型的bossGroup和group。bossGroup主要处理服务端接收客户端连接处理，group主要处理读写等I/O事件及任务等；")]),t._v(" "),r("li",[t._v("创建ServerBootstrap，其主要对一些处理进行代理，如bind()等操作，其是其他类的一个简单门面；")]),t._v(" "),r("li",[t._v("channel()方法设置服务端的ServerSocketChannel实现类，本处实现类为NioServerSocketChannel。")]),t._v(" "),r("li",[t._v("option()方法设置Channel的相关选项，具体查看ChannelOption中的定义；")]),t._v(" "),r("li",[t._v("localAddress()设置服务端绑定的本地地址及端口；")]),t._v(" "),r("li",[t._v("handler()设置服务端的对应Channel的Handler;")]),t._v(" "),r("li",[t._v("childHandler()设置子连接的Channel的Handler；")]),t._v(" "),r("li",[t._v("bind()及sync()绑定本地地址并同步返回绑定结果；")])]),t._v(" "),r("p",[t._v("在TCP/IP中，Netty 会把读到的数据放到 ByteBuf 的数据结构中。")]),t._v(" "),r("h3",{attrs:{id:"_1-2客户端启动"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2客户端启动"}},[t._v("#")]),t._v(" 1.2客户端启动")]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br")])]),r("h3",{attrs:{id:"_1-3区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3区别"}},[t._v("#")]),t._v(" 1.3区别")]),t._v(" "),r("p",[t._v("编写服务端和客户端最大的并且唯一不同的使用了不同的"),r("a",{attrs:{href:"http://netty.io/4.0/api/io/netty/bootstrap/Bootstrap.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("BootStrap"),r("OutboundLink")],1),t._v(" 和 "),r("a",{attrs:{href:"http://netty.io/4.0/api/io/netty/channel/Channel.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Channel"),r("OutboundLink")],1),t._v("的实现")]),t._v(" "),r("h2",{attrs:{id:"google-protocol-buffer-整合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#google-protocol-buffer-整合"}},[t._v("#")]),t._v(" Google Protocol Buffer 整合")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://code.google.com/apis/protocolbuffers/docs/overview.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Google Protocol Buffers"),r("OutboundLink")],1),t._v(" 是快速实现一个高效的二进制协议的理想方案。通过使用 "),r("a",{attrs:{href:"http://netty.io/4.0/api/io/netty/handler/codec/protobuf/ProtobufEncoder.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("ProtobufEncoder"),r("OutboundLink")],1),t._v(" 和 "),r("a",{attrs:{href:"http://netty.io/4.0/api/io/netty/handler/codec/protobuf/ProtobufDecoder.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("ProtobufDecoder"),r("OutboundLink")],1),t._v("，你可以把 Google Protocol Buffers 编译器 (protoc) 生成的消息类放入到 Netty 的codec 实现中。")])])}),[],!1,null,null,null);e.default=o.exports}}]);